# 金仓鼠的算法模板

[TOC]

## **Data Structure**

**数据结构是在计算机中存储、组织数据的方式。小到变量、数组，大到线段树、平衡树，都是数据结构。**

### Slicing Window(monotonous-queue)

**单调队列(滑动窗口)有两个性质**

1. 队列中的元素其对应在原来的列表中的顺序必须是单调递增的。
2. 队列中元素的大小必须是单调递*(增/减/甚至是自定义也可以)

```cpp
#include <iostream>
#include <deque>
using namespace std;
const int MAXN = 1e6+5;
int a[MAXN],maxv[MAXN],minv[MAXN];
void SWA(int n,int k)
{
	deque<int>dq;
	for (int i = 0 , j = 0; i < n ; ++i ) {					//找最小值
		while (!dq.empty() && a[dq.back()] > a[i] ) {		//去尾
			dq.pop_back();			
		}
		dq.push_back(i);
		if (i >= k - 1) {
			while (!dq.empty() && dq.front() <= i - k ) {	//剃头
				dq.pop_front();
			}
			minv[j++] = a[dq.front()];
		}
	}
	dq.clear();
	for (int i = 0 , j = 0 ; i < n ; ++i ) {				//找最大值
		while (!dq.empty() && a[dq.back()] < a[i]) {
			dq.pop_back();
		}
		dq.push_back(i);
		if (i >= k - 1) {
			while (!dq.empty() && dq.front() <= i - k ) {
				dq.pop_front();
			}
			maxv[j++] = a[dq.front()];
		}
	}
}
int main ()
{
	int n,k;
	cin >> n >> k;
	for (int i = 0 ; i < n ; ++i ) {
		cin >> a[i];
	}
	SWA(n,k);
	for (int i = 0 ; i < n - k ; ++i ) {
		cout << minv[i] << " ";
	}
	cout << minv[n - k] << endl;
	for (int i = 0 ; i < n - k ; ++i ) {
		cout << maxv[i] << " ";
	}
	cout << maxv[n - k] << endl;
	return 0;
}
```

单调栈：

```c++
// 单调栈 O(n)
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=3000005;
int n,a[N],ans[N],q[N];

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);

    int top=0;  //栈顶指针初值
    for(int i=1; i<=n; i++){
        while(top>0 && a[q[top]]<a[i]){
            ans[q[top]]=i; //记录答案
            top--;         //栈顶出栈
        }
        q[++top]=i;      //栈顶入栈
    }

    for(int i=1;i<=n;i++) printf("%d ",ans[i]);
    return 0;
}
```

### Binary Answer

解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件。把这里的枚举换成二分，就变成了「**二分答案**」。

```cpp
#include <iostream>
using namespace std;
bool check(int x)
{
    return false;
    //....			//计算y
    //最小值最大化：
	//return y <= C //x小，y小
	//return y >= C //x小, y大

    //最大值最小化 
    //return y <= C //x大，y小
	//return y >= C //x大, y大
}
//最小值最大化答案
int maxbfind(int left,int right) //二分答案left(上界)~right(下界)
{
    int l = left - 1,r = right + 1;
    while (l + 1 < r) {
        int mid = (l+r) >> 1;
        if (check(mid)) l = mid;    //最大化
        else r = mid;
    }
    return l;
}
//最大值最小化答案
int minbfind(int left,int right)
{
    int l = left - 1 , r = right + 1;
    while (l + 1 < r) {
        int mid = (l + r) >> 1;     //最小化
        if (check(mid)) l = mid;
        else r = mid;
    }
    return r;
}
```

### Binary Search

要求满足某种条件的最大值的最小可能情况（最大值最小化），首先的想法是从小到大枚举这个作为答案的「最大值」，然后去判断是否合法。若答案单调，就可以使用二分搜索法来更快地找到答案。因此，要想使用二分搜索法来解这种「最大值最小化」的题目，需要满足以下三个条件：

1. 答案在一个固定区间内；
2. 可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值是否是符合条件的；
3. 可行解对于区间满足一定的单调性。换言之，如果 $x$ 是符合条件的，那么有 $x + 1$ 或者 $x - 1$ 也符合条件。（这样下来就满足了上面提到的单调性)

当然，最小值最大化是同理的。

C++ 标准库中实现了查找首个不小于给定值的元素的函数 [`std::lower_bound`](https://zh.cppreference.com/w/cpp/algorithm/lower_bound) 和查找首个大于给定值的元素的函数 [`std::upper_bound`](https://zh.cppreference.com/w/cpp/algorithm/upper_bound)，二者均定义于头文件 `<algorithm>` 中。

二者均采用二分实现，所以调用前必须保证元素有序。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 1e6+5;
//都什么年代了还在用传统二分
int n,a[MAXN];
int bfind(int q)    //二分下标1~n
{
	int l = 0,r = n + 1;
	while (l+1<r) { //l+1==r结束
		int mid = (l + r) >> 1;
		if (a[mid] <= q) l = mid;
		else r = mid;
	}
	return l;
}
double qdfind(double y) //求一个浮点数的三次方根
{
	double l = -100,r = 100;
	while (r-1 > 1e-5) {
		double mid = (l+r)/2;
		if (mid*mid*mid <= y) l = mid;
		else r = mid;
	}
	return l;
}
```

### Merge Sort

归并排序，用来求逆序对，有时候会比树状数组、线段树快

```c++
int n,a[N],b[N]; 
void merge_sort(int l, int r){
    if(l==r) return;
    int mid=l+r>>1;
    merge_sort(l,mid);
    merge_sort(mid+1,r); 
    int i=l,j=mid+1,k=l;
    while(i<=mid && j<=r){
        if(a[i]<=a[j]) b[k++]=a[i++];
        else b[k++]=a[j++];
    }
    while(i<=mid) b[k++]=a[i++];
    while(j<=r) b[k++]=a[j++];
    for(i=l; i<=r; i++) a[i]=b[i];
}
```

### Sparse Table

除 **RMQ** 以外，还有其它的「可重复贡献问题」。例如「区间按位和」、「区间按位或」、「区间 **GCD**」，**ST** 表都能高效地解决。

```cpp
#include <iostream>
#include <cmath>
//只能解决RMQ问题
//查询最大值的话就把所有min函数改成max
//如果元素出现修改的情况请使用Fenwick或线段树
using namespace std;
const int MAXN = 1e5+5; // 假定数组大小不超过1e5+5
int arr[MAXN];
int table[MAXN][20];
int Log2[MAXN];
void buildSparseTable(int n) 
{
    int k = Log2[n] + 1;
    // 计算Log2数组，用于快速计算区间大小的对数
    Log2[1] = 0;
    for (int i = 2; i <= n; i++) {
        Log2[i] = Log2[i>>1] + 1;
    }
    // 初始化第0列（区间长度为1的情况）
    for (int i = 0; i < n; i++) {
        table[i][0] = arr[i];
    }
    // 填充其余的列
    for (int j = 1; (1 << j) <= n; j++) {
        for (int i = 0; i + (1 << j) <= n; i++) {
            // 使用递推公式，计算两个区间的最小值
            table[i][j] = min(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);
        }
    }
}

int query(int l, int r) 
{
    int k = Log2[r - l + 1];
    return min(table[l][k], table[r - (1 << k) + 1][k]);
}

int main() 
{
    int n = 8; // 数组大小
    arr[0] = 2;
    arr[1] = 4;
    arr[2] = 3;
    arr[3] = 1;
    arr[4] = 6;
    arr[5] = 7;
    arr[6] = 8;
    arr[7] = 9;

    buildSparseTable(n);

    int l = 1;
    int r = 5;
    int min_val = query(l, r);
    cout << "最小值: " << min_val << endl;

    return 0;
}
```



### Disjoint Set

并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。

并查集通常用于检验图的连通性

```c++
#include <iostream>
using namespace std;
const int MAXN = 1050;
int s[MAXN];
//初始化
void init_set()
{
	for (int i = 0 ; i < MAXN ; i++ ) s[i] = i;
}
//查找（非路径压缩）
int findset(int x)
{
	return x==s[x] ? x : findset(s[x]);
}
//查找。路径压缩版
int find_set(int x)
{
	if (x != s[x]) s[x] = find_set(s[x]);
	return s[x];
}
//查找。while循环版本
int findSet(int x)
{
	int r = x;
	while(s[x] != r) {
		r = s[r];
	}
	int i = x , j;
	while(i != r) {
		j = s[i];
		s[i] = r;
		i = j;
	}
	return r;
}
//合并
void merge_set(int x,int y)
{
	x = find_set(x);y = find_set(y);
	if (x != y) s[x] = s[y];
}
```

扩展域并查集

用来维护两类以上的集合的连通性

```c++
// 扩展域并查集 
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int n,m,a,b,s;
int p[2005];

int find(int x){
    return p[x]==x?x:p[x]=find(p[x]);
}
void unset(int x,int y){
    p[find(y)]=find(x);
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=2*n;i++) p[i]=i;
    for(int i=1;i<=m;i++){
        char ch; cin>>ch>>a>>b;
        if(ch=='F') unset(a,b);
        else unset(a,b+n),unset(b,a+n);
    }
    for(int i=1;i<=n;i++)if(p[i]==i)s++;
    cout<<s;
    return 0;
}
```

```c++
// 扩展域并查集 
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int n,k,op,x,y,ans;
int p[50005*3];
// x是同类域
// x+n是捕食域
// x+n+n是天敌域

int find(int x){
    return p[x]==x?x:p[x]=find(p[x]);
}
void unset(int x,int y){
    p[find(y)]=find(x);
}
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1; i<=3*n; i++) p[i]=i;
    for(int i=1; i<=k; i++){
        scanf("%d%d%d",&op,&x,&y);
        if(x>n||y>n) ans++;
        else if(op==1){ //x,y是同类
            //如果x在y的捕食域,或x在y的天敌域,是假话ans+1
            if(find(x)==find(y+n)||find(x)==find(y+n+n))ans++;
            else{   //是真话,合并同类集合
                unset(x,y);
                unset(x+n,y+n);
                unset(x+n+n,y+n+n);
            }
        }
        else{ //x吃y
            //如果他们在同类域,或者x在y的捕食域,是假话ans+1
            if(find(x)==find(y)||find(x)==find(y+n))ans++;
            else{   //是真话,合并同类集合
                unset(x,y+n+n); 
                unset(x+n,y);   
                unset(x+n+n,y+n);
            }
        }
    }
    printf("%d\n",ans);
}
```



### Fenwick

树状数组可以高效地**查询和维护前缀和（或区间和）**。

可以在log的复杂度下进行**单点修改+区间查询**

```c++
#include <iostream>
#include <vector>
#include <numeric>
#include <cmath>
#include <algorithm>
template <typename T>
struct Fenwick {    //树状数组
    int n;
    std::vector<T> a;
    
    Fenwick(int n = 0) {
        init(n);
    }
    
    void init(int n) {
        this->n = n;
        a.assign(n, T());
    }
    
    void add(int x, T v) {
        for (int i = x + 1; i <= n; i += i & -i /*lowbit*/) {
            a[i - 1] += v;
        }
    }
    
    T sum(int x) {
        auto ans = T();
        for (int i = x; i > 0; i -= i & -i) {
            ans += a[i - 1];
        }
        return ans;
    }
    
    T rangeSum(int l, int r) {  //查询区间(l,r)
        return sum(r) - sum(l);
    }
    //解决RMQ
    //第 k 小元素查询方法（int kth(T k)）：找到使得前 x 个元素和不超过给定值 k 的最大 x 值，实际上用于定位数组中的第 k 小元素。
    int kth(T k) {
        int x = 0;
        for (int i = 1 << (int)std::log2(n); i; i /= 2) {
            if (x + i <= n && k >= a[x + i - 1]) {
                x += i;
                k -= a[x - 1];
            }
        }
        return x;
    }
};
```

### Segment Tree

线段树是算法竞赛中常用的用来维护 **区间信息** 的数据结构。

线段树可以在 $O(\log N)$ 的时间复杂度内实现**单点修改**、**区间修改**、**区间查询**等操作。

```c++
#include <iostream>
using namespace std;
const int MAXN = 1e6+5;
template<typename T>
struct SegmentTree {
	int n,w[MAXN];
	struct node {
		T l,r,sum,add;
	}tr[MAXN*4];
	T lc (T p)	//左子树指针
	{
		return p<<1;
	}
	T rc (T p)	//右子树指针
	{
		return p<<1|1;
	}
	void pushup(T p) //向上更新
	{
		tr[p].sum = tr[lc(p)].sum + tr[rc(p)].sum;
	}
	void pushdown (T p)	//向下更新
	{
		if (tr[p].add) {
			tr[lc(p)].sum += tr[p].add*(tr[lc(p)].r - tr[lc(p)].l + 1);
			tr[rc(p)].sum += tr[p].add*(tr[rc(p)].r - tr[rc(p)].l + 1);
			tr[lc(p)].add += tr[p].add;
			tr[rc(p)].add += tr[p].add;
			tr[p].add = 0;
		}
	}
	void build(T p,T l,T r)		//建树
	{
		tr[p] = {l,r,w[l],0};
		if (l == r) return;	//叶子
		T m = (l+r)>>1;		//不是叶子裂开
		build(lc(p),l,m);
		build(rc(p),m+1,r);
		pushup(p);
	}
	void update (T p,T x,T k)	//单点修改(+)
	{
		if (tr[p].l == x && tr[p].r == x) {
			tr[p].sum += k;
			return;
		}
		int m = (tr[p].l + tr[p].r) >> 1;
		if (x <= m) update(lc(p),x,k);
		if (x > m) update(rc(p),x,k);
		pushup(p);
	}
	void update (T p,T x,T y,T k)	//区间修改(+)
	{
		if (x <= tr[p].l && tr[p].r <= y) {
			tr[p].sum += (tr[p].r - tr[p].l + 1)*k;
			tr[p].add += k;
			return;
		}
		T m = (tr[p].l + tr[p].r)>> 1;
		pushdown(p);
		if (x <= m) update(lc(p),x,y,k);
		if (y > m) update(rc(p),x,y,k);
		pushup(p);
	}
	T query (T p,T x,T y) 		//区间查询
	{
		if (x <= tr[p].l && tr[p].r <= y) return tr[p].sum;//完全覆盖
		T m = (tr[p].l + tr[p].r) >> 1;
		pushdown(p);
		T sum = 0;
		if (x <= m) sum += query(lc(p),x,y);
		if (y > m)  sum += query(rc(p),x,y);
		return sum;
	}
};
```

### Splay

Splay树是一种自平衡的二叉搜索树，其特点是它通过“伸展”操作（splay）来保持平衡。伸展操作包括一系列节点的旋转，使得任何访问的节点都会被移动到树的根部。这样做的主要目的是提高树的访问效率，特别是对于连续访问某些特定节点的操作。

+ Splay树的核心操作

   1. **伸展（Splay）**：将指定节点旋转至根节点。这不仅可以快速访问节点，还可以部分重组树，分散潜在的不平衡。
   2. **旋转（Rotate）**：伸展操作的基础，包括左旋和右旋。旋转可以改变父子关系和子树的结构，用于调整节点位置。
   3. **插入（Insert）**：插入新节点后，进行伸展操作，确保新节点成为树的根。
   4. **删除（Delete）**：删除节点后，需要通过伸展操作调整树，确保树的平衡。
   5. **查找（Search）**：查找节点时，一旦找到目标节点，立即进行伸展操作，使之成为树的根。

+ Splay树的优势与用途

  - **自平衡性**：Splay树不需要显式的平衡条件，如AVL树或红黑树中的平衡因子或颜色规则。

  - **适用性**：特别适用于访问模式非常局部化的应用场景，例如缓存系统中经常访问的元素可以迅速被访问到。

  - **操作简便**：在动态数据结构中，Splay树可以在$O(log n)$的摊销时间复杂度内完成查找、插入和删除操作。

+ 缺点
  - **性能不稳定**：在最坏情况下，单次操作的时间复杂度可能达到O(n)，尽管摊销时间复杂度为O(log n)。
  - **代码又臭又长，二倍之于线段树**

```cpp
#include <iostream>
using namespace std;

#define ls(x) tr[x].ch[0]  // 左子节点
#define rs(x) tr[x].ch[1]  // 右子节点
const int N = 1100010;
const int INF = (1 << 30) + 1;

struct Node {
    int ch[2];  // 左右子节点
    int fa;     // 父节点
    int v;      // 节点值
    int cnt;    // 值的次数
    int siz;    // 子树大小

    void init(int p, int v1) {
        fa = p;
        v = v1;
        cnt = siz = 1;
    }
} tr[N];

int root, tot;  // 根节点编号和节点总数

// 更新节点x的子树大小
void pushup(int x) {
    tr[x].siz = tr[ls(x)].siz + tr[rs(x)].siz + tr[x].cnt;
}

// 左旋操作
void rotateLeft(int x) {
    int y = tr[x].fa, z = tr[y].fa, k = tr[y].ch[1] == x;
    tr[z].ch[tr[z].ch[1] == y] = x;
    tr[x].fa = z;
    tr[y].ch[k] = tr[x].ch[k ^ 1];
    tr[tr[x].ch[k ^ 1]].fa = y;
    tr[x].ch[k ^ 1] = y;
    tr[y].fa = x;
    pushup(y);
    pushup(x);
}

// 右旋操作
void rotateRight(int x) {
    int y = tr[x].left, z = tr[y].fa, k = tr[y].ch[1] == x;
    tr[z].ch[tr[z].ch[1] == y] = x;
    tr[x].fa = z;
    tr[y].ch[k] = tr[x].ch[k ^ 1];
    tr[tr[x].ch[k ^ 1]].fa = y;
    tr[x].ch[k ^ 1] = y;
    tr[y].fa = x;
    pushup(y);
    pushup(x);
}

// Splay操作，将节点x旋转到目标节点k的子节点
void splay(int x, int k) {
    while (tr[x].fa != k) {
        int y = tr[x].fa, z = tr[y].fa;
        if (z != k) (ls(y) == x) ^ (ls(z) == y) ? rotateLeft(x) : rotateRight(y);
        rotateLeft(x);
    }
    if (!k) root = x;
}

// 插入值为v的节点
void insert(int v) {
    int x = root, p = 0;
    while (x && tr[x].v != v) {
        p = x;
        x = tr[x].ch[v > tr[x].v];
    }
    if (x) {
        tr[x].cnt++;
    } else {
        x = ++tot;
        tr[p].ch[v > tr[p].v] = x;
        tr[x].init(p, v);
    }
    splay(x, 0);
}

// 查找值为v的节点，并将其旋转到根节点
void find(int v) {
    int x = root;
    while (tr[x].ch[v > tr[x].v] && v != tr[x].v) x = tr[x].ch[v > tr[x].v];
    splay(x, 0);
}

// 获取值为v的前驱
int getpre(int v) {
    find(v);
    int x = root;
    if (tr[x].v < v) return x;
    x = ls(x);
    while (rs(x)) x = rs(x);
    splay(x, 0);
    return x;
}

// 获取值为v的后继
int getsuc(int v) {
    find(v);
    int x = root;
    if (tr[x].v > v) return x;
    x = rs(x);
    while (ls(x)) x = ls(x);
    splay(x, 0);
    return x;
}

// 删除值为v的节点
void del(int v) {
    int pre = getpre(v);
    int suc = getsuc(v);
    splay(pre, 0);
    splay(suc, pre);
    int del = tr[suc].ch[0];
    if (tr[del].cnt > 1) {
        tr[del].cnt--;
        splay(del, 0);
    } else {
        tr[suc].ch[0] = 0;
        splay(suc, 0);
    }
}

// 获取值为v的排名
int getrank(int v) {
    insert(v);
    int res = tr[tr[root].ch[0]].siz;
    del(v);
    return res;
}

// 获取排名为k的值
int getval(int k) {
    int x = root;
    while (true) {
        if (k <= tr[ls(x)].siz) x = ls(x);
        else if (k <= tr[ls(x)].siz + tr[x].cnt) break;
        else k -= tr[ls(x)].siz + tr[x].cnt, x = rs(x);
    }
    splay(x, 0);
    return tr[x].v;
}

// 主函数
int main() {
    insert(-INF);
    insert(INF);
    int n, op, x;
    scanf("%d", &n);
    while (n--) {
        scanf("%d%d", &op, &x);
        if (op == 1) insert(x);
        else if (op == 2) del(x);
        else if (op == 3) printf("%d\n", getrank(x));
        else if (op == 4) printf("%d\n", getval(x + 1));
        else if (op == 5) printf("%d\n", tr[getpre(x)].v);
        else printf("%d\n", tr[getsuc(x)].v);
    }
    return 0;
}

```



## **DP**

**~~什么？动态规划还有模板？~~**

**实际上，许多广为人知的模板算法（ST、Floyd、Tarjan、KMP..）都用了动态规划的思想**

### 0-1 Knapsack

已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 $W$。

DP 状态 $dp_{i,j}$ 为在只能放前  $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。

由此可以得出状态转移方程：**$$ dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j-w_{i}}+v_{i}) $$**

这里如果直接采用二维数组对状态进行记录，会出现 MLE。可以考虑改用滚动数组的形式来优化。

由于对 $dp_{i,j}$ 有影响的只有 $dp_{i-1}$，可以去掉第一维，直接用 $dp_{i}$ 来表示处理到当前物品时背包容量为 $i$ 的最大价值，得出以下方程：**$$ dp_j=\max \left(dp_j,dp_{j-w_i}+v_i\right) $$**

**大部分背包问题的转移方程都是在此基础上推导出来的。下面是0-1背包模板**

```cpp
#include <iostream>
using namespace std;
const int MAXN = 10005;
int dp[MAXN],a[MAXN],v[MAXN];
int main ()
{
	int t,m;
	cin >> t >> m;
	for (int i = 1 ; i <= m ; i++ ) {
		cin >> a[i] >> v[i];
	}
	for (int i = 1 ; i <= m ; i++ ) {
		for (int j = t ; j >= a[i] ; j-- ) {
			if (dp[j] <= dp[j-a[i]] + v[i]) {
				dp[j] = dp[j-a[i]] + v[i];
			}
		} 
	}
	cout << dp[t] << endl;
	return 0;
}
```

### Complete Knapsack

完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。

0-1背包的二层循环从前往后遍历就是完全背包啦

```cpp
#include <iostream>
using namespace std;
const int MAXN = 10005;
int dp[MAXN],a[MAXN],v[MAXN];
int main ()
{
	int t,m;
	cin >> t >> m;
	for (int i = 1 ; i <= m ; i++ ) {
		cin >> a[i] >> v[i];
	}
	for (int i = 1 ; i <= m ; i++ ) {
		for (int j = a[i] ; j <= t ; j++ ) {
			if (dp[j] <= dp[j-a[i]] + v[i]) {
				dp[j] = dp[j-a[i]] + v[i];
			}
		} 
	}
	cout << dp[t] << endl;
	return 0;
}
```

### Multi-Knapsack

多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品有 $k_i$个，而非一个。

朴素的转移方程为 $$dp_{i,j}=\max_{k=0}^{k_i}(dp_{i-1,j-k\times w_i}+v_i\times k)$$。时间复杂度 $O(W\sum k_i)$。

考虑优化 $dp_i$ 的转移。为方便表述，设 $$g_{x,y}=dp_{i,x\times w_i+y},g'_{x,y}=dp_{i-1,x\times w_i+y}$$，则转移方程可以表示为：$$g_{x,y}=\max_{k=0}^{k_i}(g'_{x-k,y}+v_i\times k) $$

设 $$G_{x,y}=g'_{x,y}-v_i\times x$$。则方程可以表示为：$$ g_{x,y}=\max_{k=0}^{k_i}(G_{x-k,y})+v_i\times x $$

这样就转化为一个经典的单调队列优化形式了。![G_{x,y}](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 可以 $O(1)$ 计算，因此对于固定的 $y$，我们可以在 $O\left( \left\lfloor \dfrac{W}{w_i} \right\rfloor \right)$ 的时间内计算出 $g_{x,y}$。因此求出所有 $g_{x,y}$ 的复杂度为 $O\left( \left\lfloor \dfrac{W}{w_i} \right\rfloor \right)\times O(w_i)=O(W)$ 。这样转移的总复杂度就降为 $O(nW)$。

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int MAXN = 1e5+5;
int n,C,dp[MAXN],q[MAXN],num[MAXN];
//状态转移方程：dp[b + y*c[i]] = max(dp[b + x*c[i]] - x * v[i] + y*w[i])
int main ()
{
	cin >> n >> C;
	memset(dp,0,sizeof(dp));
	for (int i = 1 ; i <= n ; ++i ) {
		int w,c,m;
		cin >> w >> c >> m;
		if (m > C/c) {
			m = C/c;
		}
		for (int b = 0 ; b < c ; ++b ) {
			int head = 1,tail = 1;
			for (int y = 0 ; y <= (C-b)/c ; ++y ) {
				int tmp = dp[b + y*c] - y*w;
				while (head < tail && q[tail - 1] <= tmp) {
					tail--;
				}
				q[tail] = tmp;
				num[tail++] = y;
				while(head < tail && y - num[head] > m) { 
					head++;
				}
				dp[b + y*c] = max(dp[b + y*c] , q[head] + y*w);
			}
		}
	}
	cout << dp[C] << endl;
	return 0;
}
```

### Digital Statistics

数位统计DP的题目一般具有这几个特征：

1. 要求统计满足一定条件的数的数量（即，最终目的为计数）；
2. 这些条件经过转化后可以使用「**数位**」的思想去理解和判断；
3. 输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；
4. 上界很大（比如 $10^{18}$)，暴力枚举验证会超时。

```cpp
#include <iostream>
using namespace std;
#define int long long
const int MAXN = 20;
int ten[MAXN], dp[MAXN], cnta[MAXN], cntb[MAXN],num[MAXN];
void init() 
{
	ten[0] = 1;						//10的i次方
	for (int i = 1 ; i < MAXN ; ++i ) {
		dp[i] = i*ten[i-1];			//或者写成dp[i] = dp[i-1]*10+ten[i-1];
		ten[i] = 10*ten[i-1];
	}
}
//数位统计dp
void digitalStatistics(int x,int *cnt)
{
	int len = 0;				//数字有多少位
	while (x) {					//分解x。num[i]为第i位数字
		num[++len] = x%10;
		x /= 10;
	}
	for (int i = len ; i >= 1 ; --i ) {		//从高位到低位处理x的每一位
		for (int j = 0 ; j <= 9 ; ++j ) {	
			cnt[j] += dp[i-1]*num[i];
		}
		for (int j = 0 ; j < num[i] ; ++j ) {	//特判最高位比num[i]小的数字
			cnt[j] += ten[i-1];
		}
		int num2 = 0;
		for (int j = i - 1 ; j >= 1 ; --j) {	
			num2 = num2*10 + num[j];
		}
		cnt[num[i]] += num2 + 1;		//特判最高位数字num[i]
		cnt[0] -= ten[i-1];				//减去前导0
	}
}
void query(int a,int b)
{
	digitalStatistics(a-1,cnta);
	digitalStatistics(b,cntb);
}
signed main () 
{
	init();
	int a,b;cin >> a >> b;
	query(a,b);
	for (int i = 0 ; i < 10 ; ++i ) {
		cout << cntb[i] - cnta[i] << " ";
	}
	return 0;
}
```

二进制数位 DP 是一种动态规划的方法，主要用于解决与二进制数位相关的问题。这种方法通常会通过状态压缩的方式，将状态表示成一个二进制数，然后利用位运算来实现状态转移和状态压缩。

以下是二进制数位 DP 的一般思路和步骤：

1. **确定状态：** 将问题的状态表示为一个二进制数。这个二进制数的每一位可以代表一个对象或一种状态，也可以表示某种选择。
2. **定义状态转移方程：** 根据问题的要求，定义状态之间的转移关系。通常使用位运算操作来更新状态。
3. **处理边界情况：** 一般情况下，二进制数位 DP 需要一个初始状态。处理状态转移时，考虑边界情况，使得状态转移的逻辑完备。
4. **遍历状态：** 使用迭代或递归的方式遍历所有可能的状态，并根据状态转移方程更新状态。
5. **求解最终答案：** 根据问题的要求，最终通过状态得到问题的解。

下面通过一个例子来说明二进制数位 DP 的应用：

**问题：** 给定一个集合 S 和一个整数 K，求集合 S 的子集中，满足子集元素的异或和为 K 的子集个数。

**解决思路：**

1. **状态表示：** 用一个二进制数表示子集，第 i 位为 1 表示选择集合 S 中的第 i 个元素，为 0 表示不选择。
2. **状态转移方程：** 设 dp[mask] 表示异或和为 mask 的子集个数，则有： $$dp[mask] =\sum dp[mask⊕(1<<i)]$$, $$i\in s$$其中⊕表示异或运算。
3. **边界情况：** 初始状态 dp[0] 表示空集异或和为 0，初始化为 1。
4. **遍历状态：** 通过迭代或递归方式遍历所有可能的状态，按照状态转移方程更新 dp 数组。
5. **求解最终答案：** 最终答案即为 dp[K]，其中 K 表示异或和的目标值。

```c++
#include <iostream>
#include <vector>

using namespace std;

int countSubsetsWithXOR(vector<int>& S, int K) {
    int n = S.size();
    vector<int> dp(1 << n, 0);
    dp[0] = 1;
    for (int mask = 1; mask < (1 << n); ++mask) {
        for (int i = 0; i < n; ++i) {
            if ((mask & (1 << i)) != 0) {
                dp[mask] += dp[mask ^ (1 << i)];
            }
        }
    }
    return dp[K];
}

int main() {
    vector<int> S = {1, 2, 3, 4};
    int K = 5;
    int result = countSubsetsWithXOR(S, K);
    cout << "Number of subsets with XOR " << K << ": " << result << endl;
    return 0;
}
```

这个例子演示了如何使用二进制数位 DP 来解决一个集合的子集异或和问题。请注意，这只是一个简单的示例，实际问题中可能需要更复杂的状态转移和边界情况的处理。

### Interval

**区间DP**

1. 先把区间$[L,R]$切分为两部分$[L,k]$和$[k+1,R]$，$k$是切分点
2. 再把两部分$[L,k]$和$[k+1,R]$合并在一起。

+ 状态：$dp[L,R]$表示把从 $L$ 到 $R$ 合并成一堆的最小代价。
  转移：$dp[L, k]+ dp[k+1,R]+s[R] - s[L-1]→dp[L,R]$
+ 计算：$dp[L,R] = min(dp[L,R] , dp[L,k]+ dp[k+1,R]+ s[R] - s[L-1])$​
+ 初值：$dp[i, i]=0$（合并每堆石子的代价为$0$​），其余为正无穷
+ 目标值：$dp[1,n]$ 

```c++
#include <iostream>
#include <cstring>
using namespace std;
const int MAXN = 1005;
int m[MAXN],s[MAXN],dp[MAXN][MAXN];	//dp[l][r]表示从l到r合并成堆的最小代价
int main ()
{
	int n; cin >> n;
	memset(dp,0x3f,sizeof dp);	//初始化dp正无穷大
	for (int i = 1 ; i <= n ; ++i) {	
		cin >> m[i]; s[i] = s[i-1] + m[i];//前缀和
		dp[i][i] = 0;	//合并每一堆石子的代价为0
	}
	for (int len = 2 ; len <= n ; ++len) {		//阶段：枚举区间长度
		for (int l = 1 ; l + len - 1 <= n ; ++l) {	//状态：枚举区间起点
			int r = l + len - 1;			//区间终点
			for (int k = l ; k < r ; ++k) {	//决策：枚举分割点
				dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + s[r] - s[l-1]);
			}
		}
	}
	cout << dp[1][n] << endl;
	return 0;
}
```

### Edit Distance

两个单词：计算$word_1$转换为$word_2$需要的最小操作数

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 2023;
int dp[MAXN][MAXN];
int main ()
{
	string a,b;
	cin >> a >> b;
	int as = a.size(),bs = b.size();
	for (int i = 1 ; i <= as ; i++ ) {
		dp[i][0] = i;
	}
	for (int i = 1 ; i <= bs ; i++ ) {
		dp[0][i] = i;
	}
	for (int i = 1 ; i <= as ; i++ ) {
		for (int j = 1 ; j <= bs ; j++ ) {
			if (a[i-1] == b[j-1]) {
				dp[i][j] = dp[i-1][j-1];//不变
			} else {
				dp[i][j] = min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j])) + 1;//替换，插入，删除
			}
		}
	}
	cout << dp[as][bs] << endl;
	return 0;
}
```

### LCS

最长公共子序列

```cpp
#include <iostream>
#include <cstring>
using namespace std;
char a[200]="ADABBC";
char b[200]="DBDCA";
char dp[201][201];//长度数组
char p[201][201];//前驱数组
int m,n;
void LCS()	//最长长度
{
	m = strlen(a);
	n = strlen(b);
	for (int i = 1 ; i <= m ; i++ ) {
		for (int j = 1 ; j <= n ; j++ ) {
			if (a[i-1] == b[j-1]) {
				dp[i][j] = dp[i-1][j-1] + 1;
				p[i][j] = 1;
			} else if (dp[i][j-1] > dp[i-1][j]) {
				dp[i][j] = dp[i][j-1];
				p[i][j] = 2;
			} else {
				dp[i][j] = dp[i-1][j];
				p[i][j] = 3;
			}
		}
	}
	printf("%d\n",dp[m][n]);
}
void getLCS()	//倒推公共子序列
{
	int i = m , j = n , k = dp[m][n];
	char s[200];
	while(i>0&&j>0){
		if (p[i][j] == 1) {
			s[k--] = a[i-1];
			i--;j--;
		} else if (p[i][j] == 2) {
			j--;
		} else {
			i--;
		}
	}
	for (int i = 1 ; i <= dp[m][n] ; i++ ) {
		printf("%c",s[i]);
	}
	printf("\n");
}
int main ()
{
	LCS();
	getLCS();
	return 0;
}
```

## **Graph**

**图论 (Graph theory)** 是数学的一个分支，图是图论的主要研究对象。**图 (Graph)** 是由若干给定的顶点及连接两顶点的边所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。

### Structure

图的三种存储方法

```c++
///////邻接矩阵 示例 
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N=1010,M=1010;
int n,m,a,b,c;
int w[N][N];//边权 
int vis[N];

void dfs(int u){
    vis[u]=true;
    for(int v=1;v<=n;v++)
        if(w[u][v]){
            printf("%d,%d,%d\n",u,v,w[u][v]);
            if(vis[v]) continue;
            dfs(v);
        }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>a>>b>>c;
        w[a][b]=c; 
        // w[b][a]=c;
    }
    dfs(1);
    return 0;
}

///////边集数组 示例 
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N=1010,M=1010;
int n,m,a,b,c;
struct edge{
    int u,v,w;
}e[M];//边集 
int vis[N];

void dfs(int u){
    vis[u]=true;
    for(int i=1;i<=m;i++)
        if(e[i].u==u){
            int v=e[i].v,w=e[i].w;
            printf("%d,%d,%d\n",u,v,w);
            if(vis[v]) continue;
            dfs(e[i].v);
        }
}        
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>a>>b>>c;
        e[i]={a,b,c};
        // e[i]={b,a,c};
    }
    dfs(1);
    return 0;
}

///////邻接表 示例 
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

const int N=510;
int n,m,a,b,c;
struct edge{int v,w;};
vector<edge> e[N];//边集 

void dfs(int u,int fa){
    for(auto ed : e[u]){
        int v=ed.v, w=ed.w;
        if(v==fa) continue;
        printf("%d,%d,%d\n",u,v,w);
        dfs(v, u);
    } 
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){ 
        cin>>a>>b>>c,
        e[a].push_back({b,c});
        // e[b].push_back({a,c});
    }
    dfs(1, 0);
    return 0;
}

///////链式邻接表 示例 
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

const int N=510;
int n,m,a,b,c;
struct edge{int u,v,w;};
vector<edge> e;//边集
vector<int> h[N];//点的所有出边

void add(int a,int b,int c){
    e.push_back({a,b,c});
    h[a].push_back(e.size()-1);
}
void dfs(int u,int fa){
    for(int i=0;i<h[u].size();i++){
        int j=h[u][i];
        int v=e[j].v,w=e[j].w;
        if(v==fa) continue;
        printf("%d,%d,%d\n",u,v,w);
        dfs(v,u);
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>a>>b>>c,
        add(a,b,c);
        add(b,a,c);
    }  
    dfs(1, 0);
    return 0;
}

///////链式前向星 示例 
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

const int N=510,M=3000;
int n,m,a,b,c;
struct edge{int v,w,ne;};
edge e[M];//边集
int idx,h[N];//点的第一条出边 

void add(int a,int b,int c){
    e[idx]={b,c,h[a]};
    h[a]=idx++;
}
void dfs(int u,int fa){
    for(int i=h[u];~i;i=e[i].ne){
        int v=e[i].v, w=e[i].w;
        if(v==fa) continue;
        printf("%d,%d,%d\n",u,v,w);
        dfs(v,u);
    }
}
int main(){
    cin>>n>>m;
    memset(h,-1,sizeof h);
    for(int i=1;i<=m;i++){
        cin>>a>>b>>c,
        add(a,b,c);
        add(b,a,c);
    }  
    dfs(1, 0);
    return 0;
}
```



### DFS

算法通常的时间复杂度为$O(n+m)$，空间复杂度为$O(n)$，其中$n$表示点数，$m$表示边数。注意空间复杂度包含了栈空间，栈空间的空间复杂度是$O(n)$的。在平均$O(1)$​遍历一条边的条件下才能达到此时间复杂度，例如用前向星或邻接表存储图；如果用邻接矩阵则不一定能达到此复杂度。

+ 栈实现
  ```c++
  vector<vector<int>> adj;  // 邻接表
  vector<bool> vis;         // 记录节点是否已经遍历
  
  void dfs(int s) {
    stack<int> st;
    st.push(s);
    vis[s] = true;
  
    while (!st.empty()) {
      int u = st.top();
      st.pop();
  
      for (int v : adj[u]) {
        if (!vis[v]) {
          vis[v] = true;  // 确保栈里没有重复元素
          st.push(v);
        }
      }
    }
  }
  ```

+ 递归实现

  1. 邻接表
     ```c++
     vector<vector<int>> adj;  // 邻接表
     vector<bool> vis;         // 记录节点是否已经遍历
     void dfs(const int u) {
       vis[u] = true;
       for (int v : adj[u])
         if (!vis[v]) dfs(v)
     }
     ```

  2. 链式前向星
     ```c++
     void dfs(int u) {
       vis[u] = 1;
       for (int i = head[u]; i; i = e[i].x) {
         if (!vis[e[i].t]) {
           dfs(v);
         }
       }
     }
     ```

### Dijkstra(BFS)

单源最短路径

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e6+7;
struct edge {
	int to,v;
};
bool operator<(const edge &one , const edge &other) {
	return one.v > other.v;
}
int n,m,start;
vector<edge>v[MAXN];
int dis[MAXN],vis[MAXN];
priority_queue<edge>pq;
//堆优化dijkstra
void dijkstra (int s) 
{
	memset(dis,INF,sizeof(dis));
	dis[s] = 0;
	pq.push({s,233});
	while(!pq.empty()){
		int now = pq.top().to;
		pq.pop();
		vis[now] = true;
		for (auto nxt : v[now]) {
			int nx = nxt.to;
			dis[nx] = min(dis[nx],dis[now]+nxt.v);
			if (!vis[nx]) {
				pq.push({nx,dis[nx]});
			}
		}
	}
}
int main ()
{
	scanf("%d%d%d",&n,&m,&start);
	for (int i = 1 ; i <= m ; i++ ) {
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		v[x].push_back({y,z});
	}
	dijkstra(start);
	for (int i = 1 ; i < n ; i++ ){
		printf("%d ",dis[i]);
	}
	printf("%d\n",dis[n]);
	return 0;
}
```

### Floyd(DP)

全源最短路径

```c++
#include <iostream>
#define int long long
using namespace std;
const int INF = 0x3f3f3f3f3f3f3f3fLL;
const int MAXN = 405;
int dp[MAXN][MAXN];
int n,m,q;
void floyd()
{
    for (int k = 0 ; k < n ; ++k) {
        for (int i = 0 ; i < n ; ++i) {
            for (int j = 0 ; j < n ; ++j ) {
                if (dp[i][j] > dp[i][k] + dp[k][j]) {
                    dp[i][j] = dp[i][k] + dp[k][j];
                }
            }
        }
    }
}
```

### SPFA

能够处理负边权，但是效率比Dijkstra低

```c++
const int inf=0x3f3f3f3f;
const int N=2010,M=6010;
int n,m;
int to[M],ne[M],w[M],h[N],tot;
int d[N],cnt[N],vis[N];

void add(int a,int b,int c){
    to[++tot]=b;w[tot]=c;
    ne[tot]=h[a];h[a]=tot;
}
bool spfa(){ //判负环
    memset(d,0x3f,sizeof d); 
    memset(vis,0,sizeof vis);
    memset(cnt,0,sizeof cnt);
    queue<int>q; 
    q.push(1); vis[1]=1; d[1]=0; 
    while(q.size()){
        int u=q.front();q.pop();vis[u]=0;
        for(int i=h[u];i;i=ne[i]){
            int v=to[i];
            if(d[v]>d[u]+w[i]){
                d[v]=d[u]+w[i];
                cnt[v]=cnt[u]+1; 
                if(cnt[v]>=n)return 1;//判边数
                if(!vis[v])q.push(v),vis[v]=1;
            }
        }
    }
    return 0;
}
```



### A*

A*算法定义了一个对当前状态$x$的估价函数$f(x)= g(x)+ h(x)$，其中$g(x)$为从初始状态到达当前状态的实际代价，$h(x)$为从当前状态到达目标状态的最佳路径的估计代价。每次取出$f(x)$最优的状态$x$​​，扩展其所有子状态，可以用优先队列来维护这个值。

在求解$k$短路问题时，令$h(x)$为从当前结点到达终点t的最短路径长度。可以通过在反向图上对结点t跑单源最短路预处理出对每个结点的这个值。

由于设计的距离函数和估价函数，对于每个状态需要记录两个值，为当前到达的结点$x$和已经走过的距离$g(x)$，将这种状态记为$(x, g(c))$。

开始我们将初始状态$(s,0)$加入优先队列。每次我们取出估价函数$f(x)= g(x)+h(x)$最小的一个状态，枚举该状态到达的结点$x$的所有出边，将对应的子状态加入优先队列。当我们访问到一个结点第$k$次时，对应的状态的$g(x)$就是从$x$到该结点的第$k$短路。

优化:由于只需要求出从初始结点到目标结点的第$k$短路，所以已经取出的状态到达一个结点的次数大于$k$次时，可以不扩展其子状态。因为之前k次已经形成了$k$条合法路径，当前状态不会影响到最后的答案。

当图的形态是一个$n$元环的时候，该算法最坏是$O(nklog_n)$的。但是这种算法可以在相同的复杂度内求出从起始点$s$到每个结点的前$k$短路。

```c++
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn = 5010;
const int maxm = 400010;
const int inf = 2e9;
int n, m, s, t, k, u, v, ww, H[maxn], cnt[maxn];
int cur, h[maxn], nxt[maxm], p[maxm], w[maxm];
int cur1, h1[maxn], nxt1[maxm], p1[maxm], w1[maxm];
bool tf[maxn];

void add_edge(int x, int y, double z) {
    cur++;
    nxt[cur] = h[x];
    h[x] = cur;
    p[cur] = y;
    w[cur] = z;
}

void add_edge1(int x, int y, double z) {
    cur1++;
    nxt1[cur1] = h1[x];
    h1[x] = cur1;
    p1[cur1] = y;
    w1[cur1] = z;
}
struct node {
    int x, v;
    bool operator<(node a) const { return v + H[x] > a.v + H[a.x]; }
};

priority_queue<node> q;

struct node2 {
    int x, v;
    bool operator<(node2 a) const { return v > a.v; }
} x;

priority_queue<node2> Q;

int main() {
    scanf("%d%d%d%d%d", &n, &m, &s, &t, &k);
    while (m--) {
        scanf("%d%d%d", &u, &v, &ww);
        add_edge(u, v, ww);
        add_edge1(v, u, ww);
    }
    for (int i = 1; i <= n; i++) H[i] = inf;
    Q.push({t, 0});
    while (!Q.empty()) {
        x = Q.top();
        Q.pop();
        if (tf[x.x]) continue;
        tf[x.x] = true;
        H[x.x] = x.v;
        for (int j = h1[x.x]; j; j = nxt1[j]) Q.push({p1[j], x.v + w1[j]});
    }
    q.push({s, 0});
    while (!q.empty()) {
        node x = q.top();
        q.pop();
        cnt[x.x]++;
        if (x.x == t && cnt[x.x] == k) {
            printf("%d\n", x.v);
            return 0;
        }
        if (cnt[x.x] > k) continue;
        for (int j = h[x.x]; j; j = nxt[j]) q.push({p[j], x.v + w[j]});
    }
    printf("-1\n");
    return 0;
}
```

### Toposort

判断一个图是否为有向无环图(**DAG**)

如果想要验证两点之间是非是通路，请移步并查集

```cpp
#include <iostream>
#include <stdio.h>
#include <vector>
#include <queue>
using namespace std;
const int MAXN = 1e6+5;
vector<int>e[MAXN],tp;
int n,din[MAXN];
bool toposort () 
{
    queue<int>q;
    for (int i = 1 ; i <= n ; ++i ) {
        if (din[i] == 0) {
            q.push(i);
        }
    }
    while (q.size()) {
        int x = q.front();q.pop();
        tp.push_back(x);
        for (auto y : e[x]) {
            if (--din[y] == 0) {
                q.push(y);
            }
        }
    }
    return tp.size() == n;
}
int main ()
{
    int m;
    cin >> n >> m;
    for (int i = 0 ; i < m ; ++i ) {
        int a,b;
        cin >> a >> b;
        e[a].push_back(b);
        din[b]++;
    }
    if (toposort()) puts("-1");
    else {
        for (auto x : tp) printf("%d ",x);
    }
    return 0;
}
```

### Prim

无向图的最小生成树

```c++
#include <bits/stdc++.h>
using namespace std;
#define INF INT_MAX
#define int long long int
#define il inline

int n, m;
vector<int> head, nxt, to, we, dis;
typedef struct VD
{
    int v;
    int w;
    bool operator<(const struct VD &x) const
    {
        return this->w < x.w;
    }
    // 重载大于号，让优先队列按权值排序，小的优先
    bool operator>(const struct VD &x) const
    {
        return this->w > x.w;
    }
    bool operator==(const struct VD &x) const
    {
        return this->w == x.w;
    }

} vd;
vector<bool> vis;
void init()
{
    dis.resize(n + 1, INF);
    head.resize(n + 1, -1);
    vis.resize(n + 1, false);
}

void add(int u, int v, int w)
{
    nxt.push_back(head[u]);
    head[u] = to.size();
    to.push_back(v);
    we.push_back(w);
}

// 小根堆,升序排列；不写greater<vd>大根堆，降序排列
priority_queue<vd, vector<vd>, greater<vd>> que;
int prim()
{
    int res = 0;
    dis[1] = 0;
    que.push({1, 0});
    int cnt = 0;
    while (!que.empty()) {
        if (cnt >= n)
            break;
        auto [v, d] = que.top();
        que.pop();
        if (vis[v])
            continue;
        vis[v] = true;
        ++cnt;
        res += d;
        for (int i = head[v]; ~i; i = nxt[i]) {
            int v_ = to[i];
            int w_ = we[i];
            if (w_ < dis[v_])
                dis[v_] = w_, que.push({v_, w_});
        }
    }
    if (cnt != n)
        return INF;
    return res;
}
// luogu 3366
signed main()
{
    cin >> n >> m;
    init();
    for (int i = 0, u, v, w; i < m; i++) {
        cin >> u >> v >> w;
        add(u, v, w);
        add(v, u, w);
    }

    int res = prim();
    if (res && res < INF)
        cout << res << endl;
    else
        cout << "orz" << endl;

    return 0;
}
```

### Spanning Tree

有向图上的最小生成树（Directed Minimum Spanning Tree）称为最小树形图。

+ 常用的算法是朱刘算法，可以在$O(nm)$​​时间内解决最小树形图问题。

  1. 对于每个点，选择指向它的边权最小的那条边。

  2. 如果没有环，算法终止；否则进行缩环并更新其他点到环的距离。
     ```c++
     bool solve() {
       ans = 0;
       int u, v, root = 0;
       for (;;) {
         f(i, 0, n) in[i] = 1e100;
         f(i, 0, m) {
           u = e[i].s;
           v = e[i].t;
           if (u != v && e[i].w < in[v]) {
             in[v] = e[i].w;
             pre[v] = u;
           }
         }
         f(i, 0, m) if (i != root && in[i] > 1e50) return 0;
         int tn = 0;
         memset(id, -1, sizeof id);
         memset(vis, -1, sizeof vis);
         in[root] = 0;
         f(i, 0, n) {
           ans += in[i];
           v = i;
           while (vis[v] != i && id[v] == -1 && v != root) {
             vis[v] = i;
             v = pre[v];
           }
           if (v != root && id[v] == -1) {
             for (int u = pre[v]; u != v; u = pre[u]) id[u] = tn;
             id[v] = tn++;
           }
         }
         if (tn == 0) break;
         f(i, 0, n) if (id[i] == -1) id[i] = tn++;
         f(i, 0, m) {
           u = e[i].s;
           v = e[i].t;
           e[i].s = id[u];
           e[i].t = id[v];
           if (e[i].s != e[i].t) e[i].w -= in[v];
         }
         n = tn;
         root = id[root];
       }
       return ans;
     }
     ```

+ **Tarjan** 的 **DMST**在$O(m+nlogn)$内解决最小生成树问题，采用 [左偏树](https://oi-wiki.org/ds/leftist-tree/) 与 [并查集](https://oi-wiki.org/ds/dsu/) 实现

  ```c++
  #include <bits/stdc++.h>
  using namespace std;
  typedef long long ll;
  #define maxn 102
  #define INF 0x3f3f3f3f
  struct UnionFind {
      int fa[maxn << 1];
  
      UnionFind() { memset(fa, 0, sizeof(fa)); }
  
      void clear(int n) { memset(fa + 1, 0, sizeof(int) * n); }
  
      int find(int x) { return fa[x] ? fa[x] = find(fa[x]) : x; }
  
      int operator[](int x) { return find(x); }
  };
  
  struct Edge {
      int u, v, w, w0;
  };
  
  struct Heap {
      Edge *e;
      int rk, constant;
      Heap *lch, *rch;
      
      Heap(Edge *_e) : e(_e), rk(1), constant(0), lch(NULL), rch(NULL) {}
  
      void push() {
          if (lch) lch->constant += constant;
          if (rch) rch->constant += constant;
          e->w += constant;
          constant = 0;
      }
  };
  
  Heap *merge(Heap *x, Heap *y) {
      if (!x) return y;
      if (!y) return x;
      if (x->e->w + x->constant > y->e->w + y->constant) swap(x, y);
      x->push();
      x->rch = merge(x->rch, y);
      if (!x->lch || x->lch->rk < x->rch->rk) swap(x->lch, x->rch);
      if (x->rch)
          x->rk = x->rch->rk + 1;
      else
          x->rk = 1;
      return x;
  }
  
  Edge *extract(Heap *&x) {
      Edge *r = x->e;
      x->push();
      x = merge(x->lch, x->rch);
      return r;
  }
  
  vector<Edge> in[maxn];
  int n, m, fa[maxn << 1], nxt[maxn << 1];
  Edge *ed[maxn << 1];
  Heap *Q[maxn << 1];
  UnionFind id;
  
  void contract() {
      bool mark[maxn << 1];
      // 将图上的每一个结点与其相连的那些结点进行记录。
      for (int i = 1; i <= n; i++) {
          queue<Heap *> q;
          for (int j = 0; j < in[i].size(); j++) q.push(new Heap(&in[i][j]));
          while (q.size() > 1) {
              Heap *u = q.front();
              q.pop();
              Heap *v = q.front();
              q.pop();
              q.push(merge(u, v));
          }
          Q[i] = q.front();
      }
      mark[1] = true;
      for (int a = 1, b = 1, p; Q[a]; b = a, mark[b] = true) {
          // 寻找最小入边以及其端点，保证无环。
          do {
              ed[a] = extract(Q[a]);
              a = id[ed[a]->u];
          } while (a == b && Q[a]);
          if (a == b) break;
          if (!mark[a]) continue;
          // 对发现的环进行收缩，以及环内的结点重新编号，总权值更新。
          for (a = b, n++; a != n; a = p) {
              id.fa[a] = fa[a] = n;
              if (Q[a]) Q[a]->constant -= ed[a]->w;
              Q[n] = merge(Q[n], Q[a]);
              p = id[ed[a]->u];
              nxt[p == n ? b : p] = a;
          }
      }
  }
  
  ll expand(int x, int r);
  
  ll expand_iter(int x) {
      ll r = 0;
      for (int u = nxt[x]; u != x; u = nxt[u]) {
          if (ed[u]->w0 >= INF)
              return INF;
          else
              r += expand(ed[u]->v, u) + ed[u]->w0;
      }
      return r;
  }
  
  ll expand(int x, int t) {
      ll r = 0;
      for (; x != t; x = fa[x]) {
          r += expand_iter(x);
          if (r >= INF) return INF;
      }
      return r;
  }
  
  void link(int u, int v, int w) { in[v].push_back({u, v, w, w}); }
  
  int main() {
      int rt;
      scanf("%d %d %d", &n, &m, &rt);
      for (int i = 0; i < m; i++) {
          int u, v, w;
          scanf("%d %d %d", &u, &v, &w);
          link(u, v, w);
      }
      // 保证强连通
      for (int i = 1; i <= n; i++) link(i > 1 ? i - 1 : n, i, INF);
      contract();
      ll ans = expand(rt, n);
      if (ans >= INF)
          puts("-1");
      else
          printf("%lld\n", ans);
      return 0;
  }
  ```


### Network Flow

网络是指一个有向图 $$G = (V, E)$$，有两个特殊节点：**源点** $$S$$ 和**汇点** $$T$$。每条有向边 $$(x, y) \in E$$ 都有一个权值 $$c(x, y)$$，称为边的**容量**。若 $$(x, y) \notin E$$，则 $$c(x, y) = 0$$。

用 $$f(x, y)$$ 表示边 $$(x, y)$$ 上的**流量**，$$c(x, y) - f(x, y)$$ 称为边的**剩余容量**。通常用 $$f(x, y)/c(x, y)$$ 的形式标记边上的流量与容量。

可行流应该满足：
1. **容量限制**: $$f(x, y) \leq c(x, y)$$
2. **流量守恒**: 
   $$\sum_{(u, x) \in E} f(u, x) = \sum_{(x, v) \in E} f(x, v), \quad x \neq S, \quad x \neq T$$
   $$\sum_{(S, v) \in E} f(S, v)$$ 称为整个网络的流量。

**最大流**：

从源点流向汇点的最大流量。

**增广路**：

一条从源点到汇点的所有边的剩余容量 $$\geq 0$$ 的路径。

**残留网**：

由网络中所有结点和剩余容量大于 0 的边构成的子图，这里的边包括有向边及其反向边。
建图时每条有向边 $$(x, y)$$ 都构建一条反向边 $$(y, x)$$，初始容量 $$c(y, x) = 0$$​​。构建反向边的目的是提供一个**退流管道**，一旦前面的增广路径堵死可行流，可以通过**退流管道**退流，提供了**后悔机制**。

数据结构：

e[i] 存第 i 条出边 {v, c, ne}
h[u] 存 u 的第一条岀边
mf[v] 存 S~v 的路径上的流量上限
pre[v] 存 v 的前驱边

bfs() 找增广路 (最短路思想)

1. 初始化，mf[] = 0, mf[S] = ∞, S入队。
2. 只要队不空，u 点出队，
   1. 枚举 u 的所有岀边，更新 u 的最小容量，记录前驱边，扩展儿子入队。
   2. 若能走到 T 点，返回 true。
   3. 若不能走到 T 点，返回 false。

EK() 求最大流 (类似找牙膏)

循环找增广路，每找到一条，
   1. 逆序更新残留网，容量“此消彼长”。
   2. 累加可行流，最后返回最大流。

```c++
struct edge{long long v,c ,ne; }e[M];
int h[N],idx=1;//从2,3开始配对，0作为边界判断
long long mf[N], pre[N];
void add(int a ,int b,int c){
    e[++idx]={b,c,h[a]};
    h[a]=idx;
}
add(a,b,c); add(b,a,o);//反向边
```

### EK

一次累加一个增广路的流量。复杂度$O(nm^2)$，不过实际复杂度远到不了这么大，可以求出最大流

```c++
const int MAXN = 5005;
int n,m,s,t;	//s是源点，t是汇点
struct edge {int v,c,ne;}e[MAXN*100];	//链式前向星存图
int h[MAXN],idx = 1; //从2,3开始配对
int mf[MAXN],pre[MAXN];
void add (int a,int b,int c) 
{
	e[++idx] = {b,c,h[a]};
	h[a] = idx;
}

bool bfs() //对点分层，找增广路
{
	memset(mf,0,sizeof mf);
	queue<int>q;
	q.push(s);
	mf[s] = 1e9;
	while(q.size()){
		int u = q.front();
		q.pop();
		for(int i = h[u]; i ; i = e[i].ne ){
			int v = e[i].v;
			if (mf[v] == 0 && e[i].c) {
				mf[v] = min(mf[u],e[i].c);
				pre[v] = i;
				q.push(v);
				if (v == t) return true;
			}
		}
	}
	return false;
}

int EK() //累加可行流
{
	int flow = 0;
	while(bfs()){
		int v = t;
		while (v != s) {//更新残留网
			int i = pre[v];
			e[i].c -= mf[t];
			e[i^1].c += mf[t];
			v = e[i^1].v;
		}
		flow += mf[t];
	}
	return flow;
}

signed main ()
{
	cin >> n >> m >> s >> t;
	while(m--){
		int a,b,c;cin >> a >> b >> c;
		add(a,b,c);
        add(b,a,0);//反向边，初始化容量为0
	}
	cout << EK() << endl;
	return 0;
}
```

### Dinic

一次累加多条增广路的流量,比EK算法效率高一点（对于稠密图）

```cpp
#define LL long long
#define N 10010
#define M 200010
using namespace std;

int n,m,S,T;
struct edge{LL v,c,ne;}e[M];
int h[N],idx=1; //从2,3开始配对
int d[N],cur[N];

void add(int a,int b,int c){
    e[++idx]={b,c,h[a]};
    h[a]=idx;
}
bool bfs(){ //对点分层，找增广路
    memset(d,0,sizeof d);
    queue<int>q; 
    q.push(S); d[S]=1;
    while(q.size()){
        int u=q.front(); q.pop();
        for(int i=h[u];i;i=e[i].ne){
            int v=e[i].v;
            if(d[v]==0 && e[i].c){
                d[v]=d[u]+1;
                q.push(v);
                if(v==T)return true;
            }
        }
    }
    return false;
}
LL dfs(int u, LL mf){ //多路增广
    if(u==T) return mf;
    LL sum=0;
    for(int i=cur[u];i;i=e[i].ne){
        cur[u]=i; //当前弧优化
        int v=e[i].v;
        if(d[v]==d[u]+1 && e[i].c){
            LL f=dfs(v,min(mf,e[i].c));
            e[i].c-=f; 
            e[i^1].c+=f; //更新残留网
            sum+=f; //累加u的流出流量
            mf-=f;  //减少u的剩余流量
            if(mf==0)break;//余量优化
        }
    }
    if(sum==0) d[u]=0; //残枝优化
    return sum;
}
LL dinic(){ //累加可行流
    LL flow=0;
    while(bfs()){
        memcpy(cur, h, sizeof h);
        flow+=dfs(S,1e9);
    }
    return flow;
}
int main(){
    int a,b,c;
    scanf("%d%d%d%d",&n,&m,&S,&T);
    while(m -- ){
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c); add(b,a,0);
    }
    printf("%lld\n",dinic());
    return 0;
}
```

**割的定义**

对于一个网络 $$G = (V, E)$$，我们切一刀，将所有的点划分为 $$S$$ 和 $$T$$ 两个集合，称为割 $$(S, T)$$，其中源点 $$s \in S$$，汇点 $$t \in T$$。对于任意一个割 $$(S, T)$$，都会使得网络断流。

**割的容量**

割的容量 $$c(s, t)$$ 表示所有从 $$S$$ 到 $$T$$ 的出边的容量之和。

**最小割**

最小割就是求得一个割 $$(S, T)$$，使得割的容量 $$c(s, t)$$ 最小。最小割的方案往往并不是唯一的。

**最大流最小割定理**$$f(s, t)_{\max} = c(s, t)_{\min}$$

**证明**

假设最小割 < 最大流，割断一些边后，网络流还没有达到最大，还可以找到 $$S$$ 到 $$T$$ 的增广路，这与割的定义矛盾，故最小割 ≥ 最大流。
给出一个最小割 = 最大流的构造方案即可。求出最大流后，从源点开始对残留网 DFS，标记能够到达的点，则标记的点构成 $$S$$ 集合，未标记的点构成 $$T$$ 集合。此割就是最小割。

**结论：最大流=最小割**

```cpp
//Dinic板子   最小割就是最大流
//最小割的最少边数
idx=1;
memset(h,0,sizeof h);
for(int i=1;i<=m;i++){
    add(a[i],b[i],1); 
    add(b[i],a[i],0);
}
printf("%d\n",dinic());  
return 0;
```

## **Math**

计算机科学与数学紧密相关，而在算法竞赛中尤其强调以**数论、排列组合、概率期望、多项式**为代表离散、具体的数学：其注重程序实现和现实问题，可以出现在几乎任何类别的题目中。

### Primality Test

试除法：

```cpp
bool isPrime(int num) 
{
    if (num <= 1) {
        return false;
    }
    for (int i = 2; i <= sqrt(num); ++i) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}
```

### Count Bits

判断一个数的二进制位数

```cpp
int count_bits(int x) 
{
	int count = 0; 
	while (x) { 
		count++;
		x &= (x - 1);//x >>= 1;
	} 
	return count; 
}
```

### Factorize

分解一个数的所有因数，并把它们存到一个vector容器中

```cpp
void factorize(int num, vector<int>& factors) {
	for (int i = 1; i * i <= num; ++i) {
		if (num % i == 0) {
			factors.push_back(i);
			if (i != num / i) {  // 避免重复添加平方根
				factors.push_back(num / i);
			}
		}
	}
}
```

### Eratosthenes Sieve

埃氏筛

```cpp
#include <iostream>
using namespace std;
const int N = 1e7;
int prime[N+1];
bool vis[N+1];
int E_sieve(int n) 
{
    int k = 0;
    for (int i = 0 ; i <= n ; ++i ) {
        vis[i] = false;
    }
    for (int i = 2 ; i <= n ; ++i ) {
        if (!vis[i]) {
            prime[k++] = i;
            for (int j = 2*i ; j <= n ; j += i) {
                vis[j] = true;
            }
        }
    }
    return k;
}
```

### Euler Sieve

```c++
#include <iostream>
#include <cstring>
using namespace std;
const int N = 1e7;
int prime[N+1];
bool vis[N+1];
int euler_seive(int n)                              //欧拉筛。返回素数个数
{                                                   //
    int cnt = 0;                                    //记录素数个数
    memset(vis,0,sizeof(vis));
    memset(prime,0,sizeof(prime));
    for (int i = 2 ; i <= n ; ++i) {                //检查每个数。筛去其中的合数
        if (!vis[i])    prime[cnt++] = i;           //如果没有筛过。是素数。记录；第一个素数为2
        for (int j = 0 ; j < cnt ; ++j ) {          //用已经得到的素数去筛后面的数
            if (i*prime[j] > n) break;              //只筛小于等于n的数
            vis[i*prime[j]] = 1;                    //关键1：用x的最小质因数筛去x
            if (i % prime[j]==0) break;             //关键2：如果不是这个数的最小质因数。则结束
        }
    }
    return cnt;
}
```

### Euler's Function

1. 欧拉函数定义：$1$~$n$ 中与 $n$ 互质的数的个数称为欧拉函数，记为 $\phi(n)$。   例：$\phi(1) = 1$, $\phi(2) = 1$, $\phi(3) = 2$, $\phi(4) = 2$, $\phi(5) = 4$​

2. 欧拉函数性质：

   1. 若 $p$ 是素数，则 $\phi(p) = p - 1$
   2. $p$ 是素数，则 $\phi(p^k) = (p - 1)p^{k-1}$ 
   3.  积性函数：设 $n$ 和 $m$ 互质，则 $\gcd(m, n) = 1$, 则 $\phi(mn) = \phi(m)\phi(n)$​

3. 欧拉函数的计算公式 

   给定一个正整数 $n$，其唯一分解定理表示为 $n = p_1^{a_1} p_2^{a_2} \ldots p_s^{a_s}$，其中 $p_1, p_2, \ldots, p_s$ 是质数，而 $a_1, a_2, \ldots, a_s$ 是对应的指数。欧拉函数 $\phi(n)$ 可以通过以下公式计算：

   $$
   \phi(n) = \phi(p_1^{a_1}) \phi(p_2^{a_2}) \ldots \phi(p_s^{a_s}) = p_1^{a_1} \left(1 - \frac{1}{p_1}\right) p_2^{a_2} \left(1 - \frac{1}{p_2}\right) \ldots p_s^{a_s} \left(1 - \frac{1}{p_s}\right)
   $$

   这个公式可以进一步简化为：

   $$
   \phi(n) = n \left(1 - \frac{1}{p_1}\right) \left(1 - \frac{1}{p_2}\right) \ldots \left(1 - \frac{1}{p_s}\right)
   $$

   这表明 $\phi(n)$ 等于 $n$ 乘以所有其质因数 $p_i$ 的 $(1 - \frac{1}{p_i})$ 的乘积。

4. 由此可以得出 $n$ 和所有质因子的关系，与素数的乘积。 例：$\phi(12) = 12 \times (1 - \frac{1}{2}) \times (1 - \frac{1}{3}) = 4$

试除法求欧拉函数：

```cpp
int phi(int n){ //试除法求欧拉函数
    int res = n;
    for(int i=2; i*i<=n; i++){
        if(n%i == 0){
            res = res/i*(i-1);
            while(n%i == 0) n /= i;
        }
    }
    if(n>1) res = res/n*(n-1);
    return res;
}
```

筛法求欧拉函数：

```c++
const int N = 1000010;
int p[N], vis[N], cnt;
int phi[N];

void get_phi(int n){//筛法求欧拉函数
    phi[1] = 1;
    for(int i=2; i<=n; i++){
        if(!vis[i]){
            p[cnt++] = i;
            phi[i] = i-1;
        }
        for(int j=0; i*p[j]<=n; j++){
            int m = i*p[j];
            vis[m] = 1;
            if(i%p[j] == 0){
                phi[m] = p[j]*phi[i];
                break;
            }
            else
                phi[m]=(p[j]-1)*phi[i];
        }
    }
}
```

### Fastpow

快速幂

```cpp
#include <iostream>
#define int long long
using namespace std;
int fastPow(int a,int n,int mod)
{
    int ans = 1;
    a %= mod;
    while (n) {
        if (n & 1) {
            ans = (ans * a) % mod;
        }
        a = (a*a)%mod;
        n >>= 1;
    }
    return ans;
}
int fastPow(int a,int n)
{
    int ans = 1;
    while (n) {
        if (n&1) ans *= a;
        a *= a;
        n >>= 1;
    }
    return ans;
}
```

+ high-precision FastPow

  ```c++
  const int N=500;
  typedef vector<int> VI;
  VI a(N),res(N);
  int p;
  
  VI mul(VI &a, VI &b){//高精度
      VI t(N*2);
      for(int i=0; i<N; i++)
          for(int j=0; j<N; j++){
              t[i+j] += a[i]*b[j];
              t[i+j+1] += t[i+j]/10;
              t[i+j] %= 10;    
          }
      return t;
  }
  void quickpow(int p){//快速幂
      res[0]=1, a[0]=2;
      while(p){
          if(p & 1) res = mul(res,a);
          a = mul(a,a);
          p >>= 1;
      }
      res[0]--; //个位修正
  }
  int main(){
      cin >> p;
      printf("%d\n",int(p*log10(2))+1);
      quickpow(p);
      for(int i=0, k=499; i<10; i++){
          for(int j=0; j<50; j++, k--)
              printf("%d",res[k]);
          puts("");
      }
      return 0;
  }
  ```

### Inverse Divisor

除法不能直接取模

```c++
#include <iostream>
void extend_gcd(int a,int b,int& x,int& y)
{
	if(b==0){
		x=1;
		y=0;
		return;
	}
	extend_gcd(b,a%b,x,y);
	int temp = x;
	x = y;
	y = temp-(a/b)*y;
}
//除法/分数取模
int mod_inverse(int a,int m){
	int x,y;
	extend_gcd(a,m,x,y);
	return (x%m+m)%m;
}
```

### Lucas

计算$C_n^r mod M$。其中 $M$ 只能是质数

```cpp
#include <iostream>
#define int long long
using namespace std;
const int MAXN = 100010;
int fac[MAXN];
void initFac(int mod)       //阶乘打个表先
{
    fac[0] = 1;
    for (int i = 1 ; i <= mod ; ++i ) {
        fac[i] = (fac[i-1]*i)%mod;
    }
}
int fastPow(int a,int n,int mod)
{
	int ans = 1;
	a %= mod;
	while (n) {
		if (n & 1) {
			ans = (ans * a) % mod;
		}
		a = (a*a)%mod;
		n >>= 1;
	}
	return ans;
}
int inverse (int a,int mod)     //费马小定理除法取模
{
	return fastPow(fac[a],mod-2, mod);
}
int C(int n,int r,int mod)
{
	if (r > n) {
		return 0;
	}
	return ((fac[n]*inverse(r,mod))%mod * (inverse(n - r, mod)) % mod);
}
int lucas (int n ,int r , int mod)
{
	if (r == 0) {
		return 1;
	}
	return C(n%mod,r%mod,mod) * lucas(n/mod, r/mod, mod);
}
signed main ()
{
	int t; cin >> t;
	while (t--) {
		int n,m,p;
		cin >> n >> m >> p;
		initFac(p);
		cout << lucas(n+m,n,p)%p << endl;
	}
	return 0;
}
```

### Wilson

**威尔逊定理**

$$(p - 1)! \equiv -1 \pmod{p}$$ 是 $$p$$ 为质数的充要条件

**推论**

1. 若 $$p$$ 是质数，则 $$(p - 1)! + 1 \equiv 0 \pmod{p}$$
2. 若 $$p$$ 是大于 4 的合数，则 $$(p - 1)! \equiv 0 \pmod{p}$$​

```cpp
typedef long long LL;
const int N = 1000001;
const int mx = 3000008;
int s[N],p[N],vis[mx],t,n;
void get_prim(){
    for(LL i = 2; i < mx; ++i)
        if(!vis[i]){
            if((i-7)%3 == 0) 
                p[(i-7)/3] = 1;
            for(LL j=i*i; j<mx; j+=i) 
                vis[j] = 1;
        }
}
int main(){
    get_prim();
    for(int i=2; i<N; ++i)
        s[i] = s[i-1]+p[i];
    scanf("%d", &t);
    while(t--){
        scanf("%d", &n);
        printf("%d\n", s[n]);
    }
}
```

### Nim

尼姆游戏：给出n堆石子，轮流在其中一堆去任意个，谁不能去谁就输。

思路：证明所有石子异或和为0则先手必输

证明：

1. 反正最终情况就是每堆都为0，先手必输，所以我们考虑怎么把情况转换到这里。
2. 如果异或和的最高位为i，则有一堆石子第i为为1（不然怎么会有i位）
3. 设A1就为那堆石子，其他堆石子异或和设为x，总异或和设为k，则 A1 xor x=k，把A1变成A1 xor k，那么后手面对的则是（A1 xor k）xor x=0，
4. 如果现在的异或和已经为0了（不为最终情况），那么怎么转换异或和都不能为0
5. 根据3 4点得出：如果先手异或和不为0，可以一步让后手的情况为异或和为0；如果先手异或和为0，那么后手异或和就不为0
6. 终于开始进行游戏了，如果现在先手面对的情况异或和不为0，则一直让后手异或和为0，最后面对最终情况，后手输，则先手赢；如果先手面对的情况异或和为0，后手则赢

```C
#include<stdio.h>
bool Nim(int n)
{
	int ans = 0;
	for (int i = 1 ; i <= n ; ++i ) {
		int shu; scanf("%d",&shu);
		ans ^= shu;
	}
	return ans;
}
int main()
{
	int t,n;
	scanf("%d",&t);
	while (t--) {
		scanf("%d",&n);
		puts(Nim(n) ? "Yes" : "No" );
	}
	return 0;
}
```

### Andrew

凸包问题，注意求凸包问题本身不关注除端点外边界上其他的共线点

1. 对所有点按坐标 $x$ 为第一关键字、$y$ 为第二关键字排序。第 $1$、第 $n$ 两个点一定在凸包上。
2. 先**顺序枚举**所有点，求**下凸包**。用栈维护当前在凸包上的点：新点入栈前，总要判断该弹出哪些旧点。只要新点处在由栈顶两点构成的有向直线的右侧或共线，就弹出旧点。不能弹出时，新点入栈。
3. 再**逆序枚举**所有点，求**上凸包**。用栈维护同上。

注意：每个点入栈两次，出栈不超过两次，所以总次数不超过 $4n$​。

```c++
const int MAXN = 1e6+6;
struct Point {
	double x,y;
}p[MAXN],s[MAXN];
int n,top;
double cross (Point a, Point b, Point c)
{	//叉积
	return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);
}
double dis (Point a, Point b) 
{	//距离
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
bool cmp(Point a, Point b)
{	//比较
	return a.x != b.x ? a.x < b.x : a.y < b.y;
}
double Andrew()
{
	sort(p + 1, p + n + 1, cmp); //排序
	for(int i = 1 ; i <= n; ++i){ //下凸包
		while(top > 1 && cross(s[top-1], s[top], p[i]) <= 0)top--;
		s[++top] = p[i];
	}
	int t = top;
	for(int i = n - 1 ; i >= 1; --i){ //上凸包
		while(top > t && cross(s[top-1], s[top], p[i]) <= 0)top--;
		s[++top] = p[i];
	}
	double res = 0; //周长
	for(int i = 1 ; i < top; ++i) res += dis(s[i], s[i+1]);
	return res;
}
int main ()
{
	cin >> n;
	for (int i = 1 ; i <= n ; ++i) {
		scanf("%lf%lf", &p[i].x, &p[i].y);
	}
	printf("%.2lf\n",Andrew());
	return 0;
}
```

### Fractional Programming

**分数规划**

+ 用途：求分数的最值

+ 问题：每种物品有两个权值 $$a_i$$ 和 $$b_i$$，
  选择若干个物品使得 $\frac{\sum a_i}{\sum b_i}$ 最大/最小。
  
+ 等价：给出 $a_i$ 和 $$b_i$$，求一组 $w_i \in \{0, 1\}$，

  最大化或最小化 $\frac{\sum w_i \cdot a_i}{\sum w_i \cdot b_i}$​​。

+ 若干个物品：满足给定 **约束条件** 的物品

**二分法**

**最大化**

二分一个答案 $$x$$ 
$$
\frac{\sum w_i \cdot a_i}{\sum w_i \cdot b_i} \geq x
$$

$$
\sum w_i \cdot a_i - x \sum w_i \cdot b_i \geq 0
$$

$$
\sum w_i \cdot (a_i - x b_i) \geq 0
$$

如果和式 $$\geq 0$$，说明 $$x$$ 是可行的，否则不可行。

**最小化**

二分一个答案 $$x$$ 
$$
\frac{\sum w_i \cdot a_i}{\sum w_i \cdot b_i} \leq x
$$

$$
\sum w_i \cdot (a_i - x b_i) \leq 0
$$

如果和式 $$\leq 0$$，说明 $$x$$ 是可行的，否则不可行。

**解题思路**

1. 明确 $$a_i, b_i$$ 是什么，把 $$a_i - x b_i$$ 作为新权值求和。
2. 明确**约束条件**是什么，选择合适的算法求和。

```c++
//分数规划+二分+排序 复杂度：nlogn*log(1e4)
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=1010;
int n,k;
double a[N], b[N], c[N];

bool check(double x){
    double s=0;
    for(int i=1;i<=n;++i)c[i]=a[i]-x*b[i];
    sort(c+1, c+n+1);
    for(int i=k+1;i<=n;++i) s+=c[i];
    return s>=0;
}
double find(){
    double l=0, r=1;
    while(r-l>1e-4){
        double mid=(l+r)/2;
        if(check(mid)) l=mid;//最大化
        else r=mid;
    }
    return l;
}
int main(){
    while(scanf("%d%d",&n,&k),n){
        for(int i=1;i<=n;i++)scanf("%lf",&a[i]);
        for(int i=1;i<=n;i++)scanf("%lf",&b[i]);
        printf("%.0lf\n", 100*find());    
    }
    return 0;
}
```

## **String**

字符串，就是由字符连接而成的序列。

常见的字符串问题包括**字符串匹配问题**、**子串**相关问题、前缀/后缀相关问题、回文串相关问题、**子序列**相关问题等。

### LMSR

当字符串 $$S$$ 中选定一个位置 $$i$$ 满足 $$S[i \sim n] + S[1 \sim i-1] = T$$，则 $$T$$ 是 $$S$$ 的循环同构串。

设 $$S = \text{"bcad"}$$，其循环同构串有“bcad”、“cadb”、“adbc”、“dbca”，当 $$i = 3$$ 时，得到字典序最小的循环同构串是“adbc”。

**最小表示法** 就是找出字符串 $$S$$ 的循环同构串中字典序最小的那一个。时间复杂度$O(n)$

对于循环串（或环），通常的技巧就是复制一倍，**破环成链**，然后扫描。用**三个变量指针**控制扫描，指针 $$i, j$$ 控制匹配起始位置，指针 $$k$$ 控制匹配长度。

例如：$$S = \text{acacaba}$$，复制一倍后变成 $acacabaacacaba$​。

```c++
const int MAXN = 7e5+1;
int n;
int s[MAXN];
int get_min()
{
	for (int i = 1 ; i <= n ; ++i) {
		s[n+i] = s[i];
	}
	int i = 1, j = 2, k = 0;
	while (i <= n && j <= n) {
		for (k = 0 ; k < n && s[i+k] == s[j+k] ; ++k) ;
		s[i+k] > s[j+k] ? i = i + k + 1 : j = j + k + 1;
		if (i == j) ++j;
	}
	return min(i,j);
}
```

关于为什么可以跳到i+k+1:
首先，若S【i+k】>S【j+k】，且已知S【i+0…k】=S【j+0…k】，那么对于以i…i+k开头的循环同构串，有j…j+k开头的循环同构串相对应，并保证j+…开头的循环同构串字典序更小，即保证从i至i+k开头的循环同构串都不是字典序最小的，因此没有考虑的必要。

### KMP

单模匹配前缀：线性时间复杂度匹配单个字符串

+ next[i]表示模式串patten[1,i]中相等前后串的最长长度

+ 双指针 i指针不回退 j指针来回跑

+ 核心代码：

  ```c++
  //计算next数组  这里的字符串都是下标从1开始的！！！！
  ne[1] = 0
  for (int i = 2 , j = 0 ; i <= n ; ++i) {
      while (j && patten[i] != patten[j+1]) j = ne[j];
      if (patten[i] == patten[j+1]) ++j;
      ne[i] = j;
  }
  //KMP
  for (int i = 1 ; j = 0 ; i <= m ; ++i) {
      while (j && str[i] != patten[j+1]) j = next[j];
      if (str[i] == patten[j+1]) ++j;
      if (j == n) cout << i - n + 1 << endl;
  }
  ```

  

### Z function

对于一个长度为$n$的字符串$s$，定义函数羽表示$s$和$s[i, n一1]$(即以$s[i]$开头的后缀)的最长公共前缀($LCP$)的长度，则$z$被称为$s$的**$Z$函数**。Z函数又称扩展KMP算法。特别地，$z[0]= 0$​。

下面若干样例展示了对于不同字符串的 Z 函数：

* $z(aaaaa)=[0,4,3,2,1]$
* $z(aaabaab) =[0,2,1,0,2,1,0]$
* $z(abacaba)=[0,0,1,0,3,0,1]$​

朴素算法复杂度为$O(n^2)$

```c++
vector<int> zFunction(string s) {
    int n = (int)s.length();
    vector<int> z(n);
    for (int i = 1; i < n; ++i)
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
    return z;
}
```

线性算法($O(n)$​)

```c++
vector<int> z_function(string s) {
    int n = (int)s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r && z[i - l] < r - i + 1) {
            z[i] = z[i - l];
        } else {
            z[i] = max(0, r - i + 1);
            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
        }
        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
    }
    return z;
}
```

匹配所有子串：

为了避免混淆，我们将$t$称作文本，将$p$称作模式。所给出的问题是:寻找在文本$t$中模式$p$的所有出现(occurrence)。
为了解决该问题，我们构造一个新的字符串$s =p+◇+t$，也即我们将p和t连接在一起，但是在中间放置了一个分割字符$◇$(我们将如此选取$◇$使得其必定不出现在$p$和$t$中)。
首先计算$s$的$Z$函数。接下来，对于在区间$[0,|t|一1]$中的任意i，我们考虑以$t[i]$为开头的后缀在$s$中的$Z$函数值$k=z[i+|p|+1]$。如果$k=|p|$，那么我们知道有一个$p$的出现位于$t$的第$i$个位置，否则没有$p$的出现位于$t$的第$i$个位置。
其时间复杂度(同时也是其空间复杂度)为$O(|t|＋|p|)$。

### Manacher

线性复杂度找最长回文串

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
#define int long long
const int MAXN = 110000002;
int n,dp[MAXN];			//回文半径
char str[MAXN<<1],a[MAXN];
void change ()
{
	n = strlen(a);
	int k = 0;
	str[k++] = '$';
	str[k++] = '#';
	for (int i = 0 ; i < n ; i++ ) {
		str[k++] = a[i];
		str[k++] = '#';
	}
	str[k++] = '&';
	n = k;
}
void getDP()
{
	for (int i = 1 , c ,r = 0 ; i < n ; ++i ) {
		if (i < r) {
			dp[i] = min(dp[(c<<1) - i] , dp[c] + c - i);
		} else {
			dp[i] = 1;
		}
		while (str[i - dp[i]] == str[i + dp[i]]) {
			dp[i]++;
		}
		if (i + dp[i] > r) {
			c = i;
			r = i + dp[i];
		}
	}
}

signed main ()
{
	scanf("%s",a);
	change();
	getDP();
	int ans = 1;
	for (int i = 0 ; i < n ; i++ ) {
		ans = max(ans,dp[i]);
	}
	printf("%lld\n",ans-1);
	return 0;
}
```

### Trie

字典树（前缀树）常用于：

1. 字符串检索
2. 词频统计
3. 字典序排序 （先序遍历）
4. 前缀匹配

```cpp
#include <iostream>
#include <cstring>
#include <string>
using namespace std;
const int MAXN = 1e5+5;
char s[MAXN];
int trie[MAXN][65],cnt[MAXN],idx;
int getnum(char x)			//映射字符
{
	if(x >= 'A' && x <= 'Z')  return x - 'A';				//大写字母
	else if(x >= 'a' && x <= 'z') return x - 'a' + 26;		//小写字母
	else return x - '0' + 52;								//数字
} 
void insert(char str[])
{
	int p = 0 , len = strlen(str);
	for(int i = 0 ; i < len ; i++ ) {
		int c = getnum(str[i]);
		if(!trie[p][c]) {
			trie[p][c] = ++idx;
		}
		p = trie[p][c];
	}
    cnt[p]++;
}
int find(char str[])
{
	int p = 0,len = strlen(str);
	for(int i = 0 ; i < len ; i++){
		int c = getnum(str[i]);
		if(!trie[p][c]) {
			return 0;
		}
		p = trie[p][c];
	}
	return cnt[p];
}
int main ()
{
	string str;
	for (int i = 0 ; i < 10 ; i++ ) {
		cin >> s; 
		insert(s);
		cout  << s << endl;
	}
	cout << "--------------\n";
	for (int i = 0 ; i < 5 ; i++ ) {
		cin >> s;
		cout << "次数：" << find(s.c_str()) << endl;
	}
	return 0;
}
```

### AC Automaton

AC 自动机是 **以 Trie 的结构为基础**，结合 **KMP 的思想** 建立的自动机，用于解决多模式匹配等任务。

简单来说，建立一个 AC 自动机有两个步骤：

1. 基础的 Trie 结构：将所有的模式串构成一棵 Trie。
2. KMP 的思想：对 Trie 树上所有的结点构造失配指针。

然后就可以利用它进行多模式匹配了。

1. 建立字典树
   ```c++
   void build() {
       for (int i = 0; i < 26; i++)
           if (tr[0][i]) q.push(tr[0][i]);
       while (q.size()) {
           int u = q.front();
           q.pop();
           for (int i = 0; i < 26; i++) {
               if (tr[u][i])
                   fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);
               else
                   tr[u][i] = tr[fail[u]][i];
           }
       }
   }
   ```

2. 多模式匹配
   ```c++
   int query(char *t) {
       int u = 0, res = 0;
       for (int i = 1; t[i]; i++) {
           u = tr[u][t[i] - 'a'];  // 转移
           for (int j = u; j && e[j] != -1; j = fail[j]) {
               res += e[j], e[j] = -1;
           }
       }
       return res;
   }
   ```

3. 拓扑排序优化，完整代码：
   ```c++
   #include <bits/stdc++.h>
   #define maxn 8000001
   using namespace std;
   char s[maxn];
   int n, cnt, vis[maxn], rev[maxn], indeg[maxn], ans;
   
   struct trie_node {
       int son[27];
       int fail;
       int flag;
       int ans;
   
       void init() {
           memset(son, 0, sizeof(son));
           fail = flag = 0;
       }
   } trie[maxn];
   
   queue<int> q;
   
   void init() {
       for (int i = 0; i <= cnt; i++) trie[i].init();
       for (int i = 1; i <= n; i++) vis[i] = 0;
       cnt = 1;
       ans = 0;
   }
   
   void insert(char *s, int num) {
       int u = 1, len = strlen(s);
       for (int i = 0; i < len; i++) {
           int v = s[i] - 'a';
           if (!trie[u].son[v]) trie[u].son[v] = ++cnt;
           u = trie[u].son[v];
       }
       if (!trie[u].flag) trie[u].flag = num;
       rev[num] = trie[u].flag;
       return;
   }
   
   void getfail(void) {
       for (int i = 0; i < 26; i++) trie[0].son[i] = 1;
       q.push(1);
       trie[1].fail = 0;
       while (!q.empty()) {
           int u = q.front();
           q.pop();
           int Fail = trie[u].fail;
           for (int i = 0; i < 26; i++) {
               int v = trie[u].son[i];
               if (!v) {
                   trie[u].son[i] = trie[Fail].son[i];
                   continue;
               }
               trie[v].fail = trie[Fail].son[i];
               indeg[trie[Fail].son[i]]++;
               q.push(v);
           }
       }
   }
   
   void topu() {
       for (int i = 1; i <= cnt; i++)
           if (!indeg[i]) q.push(i);
       while (!q.empty()) {
           int fr = q.front();
           q.pop();
           vis[trie[fr].flag] = trie[fr].ans;
           int u = trie[fr].fail;
           trie[u].ans += trie[fr].ans;
           if (!(--indeg[u])) q.push(u);
       }
   }
   
   void query(char *s) {
       int u = 1, len = strlen(s);
       for (int i = 0; i < len; i++) u = trie[u].son[s[i] - 'a'], trie[u].ans++;
   }
   
   int main() {
       scanf("%d", &n);
       init();
       for (int i = 1; i <= n; i++) scanf("%s", s), insert(s, i);
       getfail();
       scanf("%s", s);
       query(s);
       topu();
       for (int i = 1; i <= n; i++) cout << vis[rev[i]] << std::endl;
       return 0;
   }
   ```

   

## **Others**

### Balanced Bracket Sequence

定义一个合法括号序列（balanced bracket sequence）为仅由 $($ 和 $)$ 构成的字符串且：

- 空串 $\varepsilon$ 是一个合法括号序列。
- 如果 $s$ 是合法括号序列，那么 $(s)$ 也是合法括号序列。
- 如果  $s,t$ 都是合法括号序列，那么 $st$ 也是合法括号序列。

注：英语中一般称**左**括号为 **opening bracket**，而**右**括号是 **closing bracket**。

```cpp
#include <iostream>
using namespace std;
bool next_balanced_sequence (string &s)
{
    int n = s.size();
    int depth = 0;
    for (int i = n - 1 ; i >= 0 ; --i) {
        if (s[i] == '(') {
            depth--;
        } else {
            depth++;
        }
        if (s[i] == '(' && depth > 0) {
            depth--;
            int open = (n - i - 1 - depth) / 2;
            int close = n - i - 1 - open;
            string Next = s.substr(0,i) + ')' + string(open,'(') + string(close,')');
            s.swap(Next);
            return true;
        }
    }
    return false;
}
```

### Josephus

约瑟夫问题的线性复杂度算法

```c++
#include <iostream>
using namespace std;
int josephus(int n, int k) 
{
    if (n == 1) return 0;
    if (k == 1) return n - 1;
    if (k > n) return (josephus(n - 1, k) + k) % n;  // 线性算法
    int res = josephus(n - n / k, k);
    res -= n % k;
    if (res < 0)
        res += n;  // mod n
    else
        res += res / (k - 1);  // 还原位置
    return res;
}
```

### FastRead

快读。一般不用，除非卡常。

```cpp
int read()
{
    register int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }

    while (c >= '0' && c <= '9')
    {
        x = (x << 3) + (x << 1) + (c ^ 48);
        c = getchar();
    }

    return x * f;
}
```

### Lowbit

在算法竞赛中，`lowbit` 一般用于处理二进制表示中的最低非零位。它是一个非常有用的位运算操作，特别在树状数组（Binary Indexed Tree，BIT）等数据结构的实现中经常会用到。

`lowbit` 函数的定义如下：

```cpp
int lowbit(int x) {
    return x & -x;
}
```

这个函数返回的是 x 在二进制表示中的最低非零位所代表的值。在很多场景下，`lowbit` 的使用有助于进行高效的状态转移或者更新。

以下是 `lowbit` 在算法竞赛中的一些常见用法：

1. **树状数组（Binary Indexed Tree）：** 在树状数组中，`lowbit` 用于确定某个节点对应的区间范围。例如，在求前缀和的过程中，可以使用 `lowbit` 来找到当前节点的父节点，从而更新父节点的值。

   ```cpp
   // 在树状数组中更新节点值
   void update(int idx, int val) {
       while (idx <= n) {
           tree[idx] += val;
           idx += lowbit(idx);
       }
   }
   ```

2. **统计某个数的二进制表示中 1 的个数：** `lowbit` 可以用于统计一个二进制数中 1 的个数，通过反复清除最低位的 1 并计数的操作。

   ```cpp
   int countOnes(int x) {
       int cnt = 0;
       while (x) {
           x -= lowbit(x);
           cnt++;
       }
       return cnt;
   }
   ```

3. **找到二进制表示中最右侧的 1 的位置：** 通过 `lowbit` 找到最右侧的 1 的位置，可以用于快速定位二进制表示中的最低有效位。

   ```cpp
   int findRightmostSetBit(int x) {
       return lowbit(x);
   }
   ```

这些只是 `lowbit` 在算法竞赛中的一些典型用法。实际上，`lowbit` 还可以在其他一些场景中发挥作用，具体取决于问题的性质和数据结构的设计。在使用 `lowbit` 时，要充分理解其原理，并根据问题的要求巧妙应用。

### Bignum

高精度四则运算，这是封装类模板

```c++
#define MAXN 9999
// MAXN 是一位中最大的数字
#define MAXSIZE 10024
// MAXSIZE 是位数
#define DLEN 4

// DLEN 记录压几位
struct Big {
    int a[MAXSIZE], len;
    bool flag;  // 标记符号'-'

    Big() {
        len = 1;
        memset(a, 0, sizeof a);
        flag = 0;
    }

    Big(const int);
    Big(const char*);
    Big(const Big&);
    Big& operator=(const Big&);
    Big operator+(const Big&) const;
    Big operator-(const Big&) const;
    Big operator*(const Big&) const;
    Big operator/(const int&) const;
    // TODO: Big / Big;
    Big operator^(const int&) const;
    // TODO: Big ^ Big;

    // TODO: Big 位运算;

    int operator%(const int&) const;
    // TODO: Big ^ Big;
    bool operator<(const Big&) const;
    bool operator<(const int& t) const;
    void print() const;
};

Big::Big(const int b) {
    int c, d = b;
    len = 0;
    // memset(a,0,sizeof a);
    CLR(a);
    while (d > MAXN) {
        c = d - (d / (MAXN + 1) * (MAXN + 1));
        d = d / (MAXN + 1);
        a[len++] = c;
    }
    a[len++] = d;
}

Big::Big(const char* s) {
    int t, k, index, l;
    CLR(a);
    l = strlen(s);
    len = l / DLEN;
    if (l % DLEN) ++len;
    index = 0;
    for (int i = l - 1; i >= 0; i -= DLEN) {
        t = 0;
        k = i - DLEN + 1;
        if (k < 0) k = 0;
        g(j, k, i) t = t * 10 + s[j] - '0';
        a[index++] = t;
    }
}

Big::Big(const Big& T) : len(T.len) {
    CLR(a);
    f(i, 0, len) a[i] = T.a[i];
    // TODO:重载此处？
}

Big& Big::operator=(const Big& T) {
    CLR(a);
    len = T.len;
    f(i, 0, len) a[i] = T.a[i];
    return *this;
}

Big Big::operator+(const Big& T) const {
    Big t(*this);
    int big = len;
    if (T.len > len) big = T.len;
    f(i, 0, big) {
        t.a[i] += T.a[i];
        if (t.a[i] > MAXN) {
            ++t.a[i + 1];
            t.a[i] -= MAXN + 1;
        }
    }
    if (t.a[big])
        t.len = big + 1;
    else
        t.len = big;
    return t;
}

Big Big::operator-(const Big& T) const {
    int big;
    bool ctf;
    Big t1, t2;
    if (*this < T) {
        t1 = T;
        t2 = *this;
        ctf = 1;
    } else {
        t1 = *this;
        t2 = T;
        ctf = 0;
    }
    big = t1.len;
    int j = 0;
    f(i, 0, big) {
        if (t1.a[i] < t2.a[i]) {
            j = i + 1;
            while (t1.a[j] == 0) ++j;
            --t1.a[j--];
            // WTF?
            while (j > i) t1.a[j--] += MAXN;
            t1.a[i] += MAXN + 1 - t2.a[i];
        } else
            t1.a[i] -= t2.a[i];
    }
    t1.len = big;
    while (t1.len > 1 && t1.a[t1.len - 1] == 0) {
        --t1.len;
        --big;
    }
    if (ctf) t1.a[big - 1] = -t1.a[big - 1];
    return t1;
}

Big Big::operator*(const Big& T) const {
    Big res;
    int up;
    int te, tee;
    f(i, 0, len) {
        up = 0;
        f(j, 0, T.len) {
            te = a[i] * T.a[j] + res.a[i + j] + up;
            if (te > MAXN) {
                tee = te - te / (MAXN + 1) * (MAXN + 1);
                up = te / (MAXN + 1);
                res.a[i + j] = tee;
            } else {
                up = 0;
                res.a[i + j] = te;
            }
        }
        if (up) res.a[i + T.len] = up;
    }
    res.len = len + T.len;
    while (res.len > 1 && res.a[res.len - 1] == 0) --res.len;
    return res;
}

Big Big::operator/(const int& b) const {
    Big res;
    int down = 0;
    gd(i, len - 1, 0) {
        res.a[i] = (a[i] + down * (MAXN + 1)) / b;
        down = a[i] + down * (MAXN + 1) - res.a[i] * b;
    }
    res.len = len;
    while (res.len > 1 && res.a[res.len - 1] == 0) --res.len;
    return res;
}

int Big::operator%(const int& b) const {
    int d = 0;
    gd(i, len - 1, 0) d = (d * (MAXN + 1) % b + a[i]) % b;
    return d;
}

Big Big::operator^(const int& n) const {
    Big t(n), res(1);
    int y = n;
    while (y) {
        if (y & 1) res = res * t;
        t = t * t;
        y >>= 1;
    }
    return res;
}

bool Big::operator<(const Big& T) const {
    int ln;
    if (len < T.len) return 233;
    if (len == T.len) {
        ln = len - 1;
        while (ln >= 0 && a[ln] == T.a[ln]) --ln;
        if (ln >= 0 && a[ln] < T.a[ln]) return 233;
        return 0;
    }
    return 0;
}

bool Big::operator<(const int& t) const {
    Big tee(t);
    return *this < tee;
}

void Big::print() const {
    printf("%d", a[len - 1]);
    gd(i, len - 2, 0) { printf("%04d", a[i]); }
}

void print(const Big& s) {
    int len = s.len;
    printf("%d", s.a[len - 1]);
    gd(i, len - 2, 0) { printf("%04d", s.a[i]); }
}

char s[100024];
```

### STL

算竞中常用的C++STL函数:

- `swap(a,b)`交换两个数，来自库`<algorithm>`
- `reverse(start,end)`用于反转容器中元素顺序的函数，参数为迭代器（`std::iterator`）或内存地址（*）
- `unique(start,end)`用于去除***相邻两个重复***两个元素 ，返回的是但并不是真正意义上的删除，可以理解为挪到了后边，比如说`vector<int> v = { 1,1,2,3,3,4,5,6 };`进行unique操作后为`{1,2,3,4,5,6,1,3}`
- `sort(start,end)`有重载`sort(start,end,cmp)`，唯一真神。cmp是自定义比较函数，可以写成lambda表达式
- `lower_bound(start,end,x)`，`upper_bound(start,end,x)`：二分查找，要求数组或vector有序，返回值为`bool`，参数是迭代器（内存地址）和查找目标
